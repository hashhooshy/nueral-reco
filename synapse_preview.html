<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Neural Network App</title>
    <!-- Inter font -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap">
    <!-- Tailwind CSS from CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        canvas {
            border-radius: 1rem;
            border: 2px solid #D1D5DB; /* Light gray border for a soft look */
            background-color: #F8FAFC; /* White-like canvas for drawing */
            touch-action: none; /* Prevents mobile scrolling */
        }
    </style>
</head>
<body class="bg-blue-50 text-gray-900 flex items-center justify-center min-h-screen p-4">

    <main class="bg-gray-100 rounded-2xl shadow-xl p-8 max-w-lg w-full flex flex-col items-center space-y-6">

        <!-- Header -->
        <h1 class="text-3xl font-bold text-center text-gray-800">Custom Neural Network</h1>
        <p class="text-center text-gray-600">
            Train a neural network to recognize circles, squares, triangles, rectangles, hexagons, trapezoids, ovals, and diamonds.
        </p>

        <!-- Status and Canvas -->
        <div class="w-full text-center">
            <div id="status" class="text-sm text-gray-500 font-semibold italic h-6">Model not trained.</div>
            <canvas id="drawing-canvas" width="200" height="200" class="mt-4"></canvas>
        </div>

        <!-- Control Buttons -->
        <div class="flex flex-col space-y-4 w-full">
            <button id="classify-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg shadow-lg transition-colors duration-200" disabled>
                Classify Drawing
            </button>
            <button id="clear-btn" class="bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-6 rounded-lg shadow-lg transition-colors duration-200">
                Clear Canvas
            </button>
        </div>
        
    </main>

    <script type="module">
        const canvas = document.getElementById('drawing-canvas');
        const statusDiv = document.getElementById('status');
        const classifyBtn = document.getElementById('classify-btn');
        const clearBtn = document.getElementById('clear-btn');

        const ctx = canvas.getContext('2d');
        const IMAGE_SIZE = 28;
        const SHAPES = ['Circle', 'Square', 'Triangle', 'Rectangle', 'Hexagon', 'Trapezoid', 'Oval', 'Diamond'];
        
        let model;
        let isDrawing = false;
        let lastX = 0, lastY = 0;

        /**
         * Draws a shape on a canvas context with a given name.
         * This function is the key to generating diverse and accurate training data.
         * We randomize the size, position, and rotation for each shape.
         * @param {CanvasRenderingContext2D} context The context to draw on.
         * @param {string} shapeName The name of the shape to draw.
         */
        function drawShape(context, shapeName) {
            context.fillStyle = '#FFFFFF';
            context.fillRect(0, 0, IMAGE_SIZE, IMAGE_SIZE);
            context.strokeStyle = '#000000';
            context.lineWidth = 2;

            const size = (Math.random() * 0.5 + 0.5) * IMAGE_SIZE * 0.8; // Random size
            const x = Math.random() * (IMAGE_SIZE - size) + size / 2;
            const y = Math.random() * (IMAGE_SIZE - size) + size / 2;
            const rotation = Math.random() * Math.PI * 2;

            context.save();
            context.translate(x, y);
            context.rotate(rotation);
            context.translate(-x, -y);

            context.beginPath();
            switch (shapeName) {
                case 'Circle':
                    // Loosen the rules for circles to better represent human drawings
                    const radius = size * 0.4;
                    const segments = 20;
                    context.moveTo(x + radius, y);
                    for (let i = 1; i <= segments; i++) {
                        const angle = i * (2 * Math.PI / segments);
                        const wobble = Math.random() * 0.2 - 0.1; // -0.1 to 0.1
                        const currentRadius = radius * (1 + wobble);
                        context.lineTo(x + currentRadius * Math.cos(angle), y + currentRadius * Math.sin(angle));
                    }
                    context.closePath();
                    break;
                case 'Oval':
                    // Made the oval drawing more distinct from the new, looser circles.
                    context.beginPath();
                    context.save();
                    context.translate(x, y);
                    context.rotate(rotation);
                    context.scale(1, 0.7);
                    context.arc(0, 0, size * 0.4, 0, 2 * Math.PI);
                    context.restore();
                    break;
                case 'Square':
                case 'Rectangle':
                    context.rect(x - size / 2, y - size / 2 * (shapeName === 'Square' ? 1 : 0.7), size, size * (shapeName === 'Square' ? 1 : 0.7));
                    break;
                case 'Triangle':
                    context.moveTo(x, y - size / 2);
                    context.lineTo(x + size / 2, y + size / 2);
                    context.lineTo(x - size / 2, y + size / 2);
                    context.closePath();
                    break;
                case 'Hexagon':
                    for (let i = 0; i < 6; i++) {
                        context.lineTo(x + size * Math.cos(i * 2 * Math.PI / 6), y + size * Math.sin(i * 2 * Math.PI / 6));
                    }
                    context.closePath();
                    break;
                case 'Trapezoid':
                    const topWidth = size * (0.5 + Math.random() * 0.5);
                    const bottomWidth = size * (0.5 + Math.random() * 0.5);
                    context.moveTo(x - topWidth / 2, y - size / 2);
                    context.lineTo(x + topWidth / 2, y - size / 2);
                    context.lineTo(x + bottomWidth / 2, y + size / 2);
                    context.lineTo(x - bottomWidth / 2, y + size / 2);
                    context.closePath();
                    break;
                case 'Diamond':
                    context.moveTo(x, y - size * 0.5);
                    context.lineTo(x + size * 0.3, y);
                    context.lineTo(x, y + size * 0.5);
                    context.lineTo(x - size * 0.3, y);
                    context.closePath();
                    break;
            }
            context.stroke();
            context.restore();
        }

        // --- Canvas Drawing Logic ---
        function startDrawing(e) {
            isDrawing = true;
            [lastX, lastY] = getCoords(e);
        }

        function draw(e) {
            if (!isDrawing) return;
            const [x, y] = getCoords(e);
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.strokeStyle = '#000000'; // Black drawing color
            ctx.lineWidth = 10;
            ctx.lineCap = 'round';
            ctx.stroke();
            [lastX, lastY] = [x, y];
        }

        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches) {
                return [e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top];
            }
            return [e.clientX - rect.left, e.clientY - rect.top];
        }

        function stopDrawing() {
            isDrawing = false;
        }

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            draw(e);
        }, { passive: false });
        canvas.addEventListener('touchend', stopDrawing);
        
        // --- Model Creation and Training ---
        function createModel() {
            model = tf.sequential();
            // A CNN is designed for images. It uses filters to detect features like edges and corners.
            model.add(tf.layers.conv2d({
                inputShape: [IMAGE_SIZE, IMAGE_SIZE, 1],
                filters: 16,
                kernelSize: 3,
                activation: 'relu'
            }));
            model.add(tf.layers.maxPooling2d({poolSize: [2, 2]}));
            model.add(tf.layers.conv2d({
                filters: 32,
                kernelSize: 3,
                activation: 'relu'
            }));
            model.add(tf.layers.maxPooling2d({poolSize: [2, 2]}));
            model.add(tf.layers.flatten());
            model.add(tf.layers.dense({units: SHAPES.length, activation: 'softmax'}));
            
            model.compile({
                optimizer: tf.train.adam(),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });
            console.log('Model created and compiled.');
        }

        /**
         * Generates training data by drawing a large number of random shapes on a temporary canvas.
         */
        async function generateTrainingData() {
            statusDiv.textContent = 'Generating training data...';
            const trainingData = [];
            const labels = [];
            const numExamplesPerShape = 250; 

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = IMAGE_SIZE;
            tempCanvas.height = IMAGE_SIZE;
            const tempCtx = tempCanvas.getContext('2d');

            for (let i = 0; i < SHAPES.length; i++) {
                const shapeName = SHAPES[i];
                for (let j = 0; j < numExamplesPerShape; j++) {
                    // Draw a new random shape
                    drawShape(tempCtx, shapeName);
                    
                    // Get the image data
                    const imageData = tempCtx.getImageData(0, 0, IMAGE_SIZE, IMAGE_SIZE).data;
                    const grayscale = [];
                    for (let k = 0; k < imageData.length; k += 4) {
                        // Invert the colors to match the drawing (black on white background)
                        grayscale.push(imageData[k] / 255);
                    }
                    
                    trainingData.push(grayscale);
                    
                    const label = new Array(SHAPES.length).fill(0);
                    label[i] = 1;
                    labels.push(label);
                }
            }
            
            const xs = tf.tensor2d(trainingData, [trainingData.length, IMAGE_SIZE * IMAGE_SIZE]);
            const ys = tf.tensor2d(labels);
            
            // Reshape the training data into a 4D tensor for the CNN: [num_examples, height, width, channels]
            const reshapedXs = xs.reshape([trainingData.length, IMAGE_SIZE, IMAGE_SIZE, 1]);
            
            xs.dispose(); // Clean up the intermediate tensor.
            
            return { xs: reshapedXs, ys };
        }

        async function trainModel() {
            statusDiv.textContent = 'Generating training data...';

            const { xs, ys } = await generateTrainingData();

            statusDiv.textContent = 'Training model...';
            
            await model.fit(xs, ys, {
                epochs: 30,
                shuffle: true,
                callbacks: {
                    onEpochEnd: (epoch, logs) => {
                        statusDiv.textContent = `Training... Epoch ${epoch + 1}/30, Accuracy: ${(logs.acc * 100).toFixed(2)}%`;
                    }
                }
            });

            xs.dispose();
            ys.dispose();

            statusDiv.textContent = 'Model training complete! Now you can draw.';
            classifyBtn.disabled = false;
        }

        // --- Classification Logic ---
        async function classifyDrawing() {
            if (!model) {
                statusDiv.textContent = 'Please wait for the model to finish training.';
                return;
            }

            statusDiv.textContent = 'Classifying...';
            
            let tensor = tf.browser.fromPixels(canvas);
            tensor = tf.image.resizeBilinear(tensor, [IMAGE_SIZE, IMAGE_SIZE]);
            // Convert to grayscale and normalize
            const grayscale = tensor.mean(2).div(255);
            
            // Reshape for CNN: [1, height, width, 1]
            const inputTensor = grayscale.expandDims(0).expandDims(-1);
            
            const prediction = model.predict(inputTensor);
            const values = await prediction.data();
            const predictedClassIndex = values.indexOf(Math.max(...values));
            
            const result = SHAPES[predictedClassIndex];

            // Display a more direct and accurate message.
            statusDiv.textContent = `Looks like a ${result}!`;
            
            tensor.dispose();
            grayscale.dispose();
            inputTensor.dispose();
            prediction.dispose();
        }
        
        // --- Event Listeners and Initial Setup ---
        classifyBtn.addEventListener('click', classifyDrawing);
        clearBtn.addEventListener('click', () => {
            ctx.fillStyle = '#F8FAFC'; // Reset canvas background color
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            statusDiv.textContent = 'Canvas cleared.';
        });
        
        ctx.fillStyle = '#F8FAFC'; // Set canvas background color
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Run the main app logic
        function runApp() {
            createModel();
            trainModel();
        }
        
        window.onload = runApp;
    </script>
    
    <!-- TensorFlow.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
</body>
</html>
